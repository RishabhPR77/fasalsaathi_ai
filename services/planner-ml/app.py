import pandas as pd
import joblib
import traceback
from flask import Flask, request, jsonify
from datetime import datetime
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.multioutput import RegressorChain
import xgboost as xgb

# Initialize the Flask application
app = Flask(__name__)

# Global variable to hold the loaded model
model_pipeline = None

def load_model():
    """Load the pre-trained model from disk."""
    global model_pipeline
    model_filename = 'final_crop_model.joblib'
    try:
        model_pipeline = joblib.load(model_filename)
        print("✅ Model loaded successfully from 'final_crop_model.joblib'")
    except FileNotFoundError:
        print(f"❌ Error: Model file '{model_filename}' not found.")
        model_pipeline = None
    except Exception as e:
        print(f"❌ An error occurred while loading the model: {e}")
        model_pipeline = None

def format_prediction_to_detailed_json(raw_prediction, input_data):
    """
    Formats the raw model output into the detailed, nested JSON structure.
    """
    # Define the target columns in the same order as during training
    targets = ['total_duration_estimate'] + \
              [f'{stage}_{metric}' for stage in ['sw', 'sd_e', 'tilrr', 'stel', 'btng', 'hdng', 'flwr', 'grnm', 'grnd', 'rpng', 'hrvst'] for metric in ['tmin', 'tmax', 'rh', 'rain', 'wind', 'solar_rad']] + \
              [f'{stage}_stage_dur' for stage in ['sw', 'sd_e', 'tilrr', 'stel', 'btng', 'hdng', 'flwr', 'grnm', 'grnd', 'rpng', 'hrvst']]

    results_df = pd.DataFrame(raw_prediction, columns=targets)
    
    # Mapping from our model's stage codes to the full names and weights from the template
    stage_map = {
        "sw": {"name": "Sowing & Germination", "importance_weight": 1.4},
        "sd_e": {"name": "Seedling / Emergence", "importance_weight": 1.2},
        "tilrr": {"name": "Tillering", "importance_weight": 1.6},
        "stel": {"name": "Stem Elongation", "importance_weight": 1.4},
        "btng": {"name": "Booting", "importance_weight": 1.5},
        "hdng": {"name": "Heading", "importance_weight": 1.5},
        "flwr": {"name": "Flowering", "importance_weight": 1.6},
        "grnm": {"name": "Grain Filling", "importance_weight": 1.6},
        "rpng": {"name": "Ripening", "importance_weight": 0.9},
        "hrvst": {"name": "Harvest", "importance_weight": 0.8}
    }
    
    # Build the 'stages' list for the JSON
    stages_list = []
    for stage_code, stage_details in stage_map.items():
        pred_data = results_df.iloc[0]
        stage_entry = {
            "name": stage_details["name"],
            "duration_days": int(round(pred_data[f'{stage_code}_stage_dur'])),
            "importance_weight": stage_details["importance_weight"],
            "ideal": {
                "tmin_c": round(pred_data[f'{stage_code}_tmin'], 2),
                "tmax_c": round(pred_data[f'{stage_code}_tmax'], 2),
                "rh_pct": int(round(pred_data[f'{stage_code}_rh'])),
                "rain_mm": round(pred_data[f'{stage_code}_rain'], 2),
                "wind_kmph": round(pred_data[f'{stage_code}_wind'], 2),
                "solar_wm2": int(round(pred_data[f'{stage_code}_solar_rad']))
            },
            "forecasted": {}
        }
        stages_list.append(stage_entry)

    # Assemble the final JSON response
    final_json = {
        "meta": {
            "version": "1.0",
            "generated_at": datetime.now().strftime("%Y-%m-%d"),
            "notes": "Ideal stage-level dataset generated by the prediction model."
        },
        "crop": input_data['crop'].iloc[0],
        "region": input_data['district'].iloc[0],
        "total_duration_days": int(round(results_df['total_duration_estimate'].iloc[0])),
        "stages": stages_list
    }
    
    return final_json

@app.route("/predict", methods=['POST'])
def predict():
    """Prediction endpoint for crop growth cycles."""
    if not model_pipeline:
        return jsonify({"error": "Model is not loaded. Please check server logs."}), 500

    try:
        json_data = request.get_json()
        if not json_data:
            return jsonify({"error": "No input data provided"}), 400

        input_data = pd.DataFrame(json_data, index=[0])
        raw_prediction = model_pipeline.predict(input_data)
        
        # Use the new formatting function
        formatted_response = format_prediction_to_detailed_json(raw_prediction, input_data)

        return jsonify(formatted_response)

    except Exception as e:
        print(traceback.format_exc())
        return jsonify({"error": f"An error occurred during prediction: {e}"}), 500

if __name__ == "__main__":
    load_model()
    app.run(host='0.0.0.0', port=5000, debug=True)

